/**
 * VyOS WireGuard Configuration Generator
 * Generates VyOS configuration commands for WireGuard VPN setups
 */

class VyOSGenerator {
    constructor() {
        this.interfaceCounter = 0;
    }

    /**
     * Generate VyOS configuration for both client-server and site-to-site
     * @param {object} data Configuration data
     * @returns {Array} Array of VyOS configuration objects
     */
    generate(data) {
        if (data.type === 'client-server') {
            return this.generateClientServerConfig(data);
        } else if (data.type === 'site-to-site') {
            return this.generateSiteToSiteConfig(data);
        }
        return [];
    }

    /**
     * Generate client-server VyOS configuration
     * @param {object} data Configuration data
     * @returns {Array} VyOS configurations
     */
    generateClientServerConfig(data) {
        const interfaceName = data.interface?.name || 'wg0';
        const serverConfig = this.createServerConfig(data, interfaceName);
        
        return [
            {
                name: 'VyOS Server Configuration',
                content: serverConfig
            }
        ];
    }

    /**
     * Generate site-to-site VyOS configuration  
     * @param {object} data Configuration data
     * @returns {Array} VyOS configurations
     */
    generateSiteToSiteConfig(data) {
        const configs = [];
        
        if (data.sites && data.sites.length > 0) {
            data.sites.forEach((site, index) => {
                const interfaceName = `wg${index}`;
                const siteConfig = this.createSiteConfig(data, site, index, interfaceName);
                
                configs.push({
                    name: `VyOS Site ${index + 1} Configuration`,
                    content: siteConfig
                });
            });
        }
        
        return configs;
    }

    /**
     * Create VyOS server configuration for client-server setup
     * @param {object} data Configuration data
     * @param {string} interfaceName WireGuard interface name
     * @returns {string} VyOS configuration commands
     */
    createServerConfig(data, interfaceName) {
        let config = '';
        
        // Configuration session header
        config += '#!/bin/vbash\n';
        config += '# VyOS WireGuard Server Configuration\n';
        config += '# Generated by MT-WG Configurator\n\n';
        
        config += 'configure\n\n';
        
        // Generate server keypair if needed
        config += '# Generate WireGuard keypair\n';
        config += `generate wireguard named-keypairs ${interfaceName}\n\n`;
        
        // WireGuard interface configuration
        config += '# WireGuard Interface Configuration\n';
        config += `set interfaces wireguard ${interfaceName} address '${data.server.ip}'\n`;
        config += `set interfaces wireguard ${interfaceName} description '${data.server.name}'\n`;
        config += `set interfaces wireguard ${interfaceName} port '${data.server.port}'\n`;
        config += `set interfaces wireguard ${interfaceName} private-key '${interfaceName}'\n`;
        
        if (data.interface?.mtu && data.interface.mtu !== 1420) {
            config += `set interfaces wireguard ${interfaceName} mtu '${data.interface.mtu}'\n`;
        }
        
        config += '\n';
        
        // Client peers configuration
        if (data.clients && data.clients.length > 0) {
            config += '# Client Peers Configuration\n';
            data.clients.forEach((client, index) => {
                const peerName = `client${index + 1}`;
                config += `set interfaces wireguard ${interfaceName} peer ${peerName} address '${client.ip}'\n`;
                config += `set interfaces wireguard ${interfaceName} peer ${peerName} allowed-ips '${client.ip}'\n`;
                config += `set interfaces wireguard ${interfaceName} peer ${peerName} pubkey '${client.publicKey}'\n`;
                
                if (client.psk) {
                    config += `set interfaces wireguard ${interfaceName} peer ${peerName} preshared-key '${client.psk}'\n`;
                }
                
                config += '\n';
            });
        }
        
        // Firewall configuration
        if (data.options?.generateFirewall) {
            config += this.generateFirewallRules(interfaceName, data);
        }
        
        // NAT configuration
        if (data.options?.enableNAT) {
            config += this.generateNATRules(interfaceName, data);
        }
        
        // Commit and save
        config += '# Commit and save configuration\n';
        config += 'commit\n';
        config += 'save\n';
        config += 'exit\n\n';
        
        config += '# Note: Replace the server private key and client public keys with actual values\n';
        config += '# Server public key can be displayed with: show wireguard keypairs pubkey ' + interfaceName + '\n';
        
        return config;
    }

    /**
     * Create VyOS site configuration for site-to-site setup
     * @param {object} data Configuration data
     * @param {object} site Site-specific data
     * @param {number} siteIndex Site index
     * @param {string} interfaceName WireGuard interface name
     * @returns {string} VyOS configuration commands
     */
    createSiteConfig(data, site, siteIndex, interfaceName) {
        let config = '';
        
        // Configuration session header
        config += '#!/bin/vbash\n';
        config += `# VyOS WireGuard Site ${siteIndex + 1} Configuration\n`;
        config += '# Generated by MT-WG Configurator\n\n';
        
        config += 'configure\n\n';
        
        // Generate keypair
        config += '# Generate WireGuard keypair\n';
        config += `generate wireguard named-keypairs ${interfaceName}\n\n`;
        
        // WireGuard interface configuration
        config += '# WireGuard Interface Configuration\n';
        config += `set interfaces wireguard ${interfaceName} address '${site.localIP}'\n`;
        config += `set interfaces wireguard ${interfaceName} description 'Site-to-Site ${site.name}'\n`;
        config += `set interfaces wireguard ${interfaceName} port '${site.listenPort || 51820}'\n`;
        config += `set interfaces wireguard ${interfaceName} private-key '${interfaceName}'\n`;
        
        if (data.interface?.mtu && data.interface.mtu !== 1420) {
            config += `set interfaces wireguard ${interfaceName} mtu '${data.interface.mtu}'\n`;
        }
        
        config += '\n';
        
        // Peer configuration (other sites)
        if (data.sites && data.sites.length > 1) {
            config += '# Remote Site Peers Configuration\n';
            data.sites.forEach((remoteSite, remoteIndex) => {
                if (remoteIndex !== siteIndex) { // Don't configure self as peer
                    const peerName = `site${remoteIndex + 1}`;
                    config += `set interfaces wireguard ${interfaceName} peer ${peerName} address '${remoteSite.publicEndpoint}:${remoteSite.listenPort || 51820}'\n`;
                    config += `set interfaces wireguard ${interfaceName} peer ${peerName} allowed-ips '${remoteSite.allowedIPs || remoteSite.localNetwork}'\n`;
                    config += `set interfaces wireguard ${interfaceName} peer ${peerName} pubkey '${remoteSite.publicKey}'\n`;
                    
                    if (remoteSite.psk) {
                        config += `set interfaces wireguard ${interfaceName} peer ${peerName} preshared-key '${remoteSite.psk}'\n`;
                    }
                    
                    // Persistent keepalive for NAT traversal
                    if (data.options?.keepalive && data.options.keepalive > 0) {
                        config += `set interfaces wireguard ${interfaceName} peer ${peerName} persistent-keepalive '${data.options.keepalive}'\n`;
                    }
                    
                    config += '\n';
                }
            });
        }
        
        // Static routing for remote networks
        config += this.generateStaticRoutes(interfaceName, data, site, siteIndex);
        
        // Firewall configuration
        if (data.options?.generateFirewall) {
            config += this.generateSiteFirewallRules(interfaceName, data, site);
        }
        
        // NAT configuration if needed
        if (data.options?.enableNAT) {
            config += this.generateSiteNATRules(interfaceName, data, site);
        }
        
        // Commit and save
        config += '# Commit and save configuration\n';
        config += 'commit\n';
        config += 'save\n';
        config += 'exit\n\n';
        
        config += '# Note: Replace the private key and peer public keys with actual values\n';
        config += '# This site\'s public key can be displayed with: show wireguard keypairs pubkey ' + interfaceName + '\n';
        
        return config;
    }

    /**
     * Generate firewall rules for client-server setup
     * @param {string} interfaceName WireGuard interface name
     * @param {object} data Configuration data
     * @returns {string} Firewall configuration commands
     */
    generateFirewallRules(interfaceName, data) {
        let config = '';
        
        config += '# Firewall Configuration\n';
        
        // Global state policy
        config += 'set firewall global-options state-policy established action accept\n';
        config += 'set firewall global-options state-policy related action accept\n';
        config += 'set firewall global-options state-policy invalid action drop\n\n';
        
        // Allow WireGuard traffic on WAN interface
        config += '# Allow WireGuard traffic from WAN\n';
        config += 'set firewall ipv4 input filter rule 100 action accept\n';
        config += 'set firewall ipv4 input filter rule 100 description "Allow WireGuard"\n';
        config += `set firewall ipv4 input filter rule 100 destination port '${data.server.port}'\n`;
        config += 'set firewall ipv4 input filter rule 100 protocol udp\n\n';
        
        // Allow traffic from WireGuard clients
        config += '# Allow traffic from WireGuard interface\n';
        config += 'set firewall ipv4 input filter rule 110 action accept\n';
        config += 'set firewall ipv4 input filter rule 110 description "Allow from WireGuard clients"\n';
        config += `set firewall ipv4 input filter rule 110 inbound-interface name '${interfaceName}'\n\n`;
        
        // Allow forwarding from WireGuard interface
        config += 'set firewall ipv4 forward filter rule 100 action accept\n';
        config += 'set firewall ipv4 forward filter rule 100 description "Allow WireGuard forwarding"\n';
        config += `set firewall ipv4 forward filter rule 100 inbound-interface name '${interfaceName}'\n\n`;
        
        return config;
    }

    /**
     * Generate NAT rules for client-server setup
     * @param {string} interfaceName WireGuard interface name
     * @param {object} data Configuration data
     * @returns {string} NAT configuration commands
     */
    generateNATRules(interfaceName, data) {
        let config = '';
        
        config += '# NAT Configuration\n';
        
        // Source NAT for WireGuard clients
        const serverNetwork = this.extractNetwork(data.server.ip);
        if (serverNetwork) {
            config += `set nat source rule 100 description 'WireGuard NAT'\n`;
            config += `set nat source rule 100 outbound-interface name 'eth0'\n`;
            config += `set nat source rule 100 source address '${serverNetwork}'\n`;
            config += `set nat source rule 100 translation address 'masquerade'\n\n`;
        }
        
        return config;
    }

    /**
     * Generate static routes for site-to-site setup
     * @param {string} interfaceName WireGuard interface name
     * @param {object} data Configuration data
     * @param {object} site Current site data
     * @param {number} siteIndex Site index
     * @returns {string} Routing configuration commands
     */
    generateStaticRoutes(interfaceName, data, site, siteIndex) {
        let config = '';
        
        if (data.sites && data.sites.length > 1) {
            config += '# Static Routes for Remote Sites\n';
            
            data.sites.forEach((remoteSite, remoteIndex) => {
                if (remoteIndex !== siteIndex) { // Don't route to self
                    const remoteNetwork = remoteSite.allowedIPs || remoteSite.localNetwork;
                    if (remoteNetwork) {
                        config += `set protocols static interface-route ${remoteNetwork} next-hop-interface ${interfaceName}\n`;
                    }
                }
            });
            
            config += '\n';
        }
        
        return config;
    }

    /**
     * Generate firewall rules for site-to-site setup
     * @param {string} interfaceName WireGuard interface name
     * @param {object} data Configuration data
     * @param {object} site Site data
     * @returns {string} Firewall configuration commands
     */
    generateSiteFirewallRules(interfaceName, data, site) {
        let config = '';
        
        config += '# Firewall Configuration\n';
        
        // Global state policy
        config += 'set firewall global-options state-policy established action accept\n';
        config += 'set firewall global-options state-policy related action accept\n';
        config += 'set firewall global-options state-policy invalid action drop\n\n';
        
        // Allow WireGuard traffic
        config += '# Allow WireGuard traffic\n';
        config += 'set firewall ipv4 input filter rule 100 action accept\n';
        config += 'set firewall ipv4 input filter rule 100 description "Allow WireGuard S2S"\n';
        config += `set firewall ipv4 input filter rule 100 destination port '${site.listenPort || 51820}'\n`;
        config += 'set firewall ipv4 input filter rule 100 protocol udp\n\n';
        
        // Allow traffic from WireGuard interface
        config += 'set firewall ipv4 input filter rule 110 action accept\n';
        config += 'set firewall ipv4 input filter rule 110 description "Allow from WireGuard tunnel"\n';
        config += `set firewall ipv4 input filter rule 110 inbound-interface name '${interfaceName}'\n\n`;
        
        // Allow forwarding between sites
        config += 'set firewall ipv4 forward filter rule 100 action accept\n';
        config += 'set firewall ipv4 forward filter rule 100 description "Allow site-to-site forwarding"\n';
        config += `set firewall ipv4 forward filter rule 100 inbound-interface name '${interfaceName}'\n\n`;
        
        return config;
    }

    /**
     * Generate NAT rules for site-to-site setup
     * @param {string} interfaceName WireGuard interface name
     * @param {object} data Configuration data
     * @param {object} site Site data
     * @returns {string} NAT configuration commands
     */
    generateSiteNATRules(interfaceName, data, site) {
        let config = '';
        
        // Usually site-to-site doesn't need NAT, but if local network needs to reach remote sites
        if (site.localNetwork) {
            config += '# NAT Configuration (if needed)\n';
            config += `# set nat source rule 100 description 'Site-to-Site NAT'\n`;
            config += `# set nat source rule 100 outbound-interface name '${interfaceName}'\n`;
            config += `# set nat source rule 100 source address '${site.localNetwork}'\n`;
            config += `# set nat source rule 100 translation address 'masquerade'\n\n`;
        }
        
        return config;
    }

    /**
     * Extract network from IP/CIDR
     * @param {string} ip IP address with CIDR
     * @returns {string} Network address
     */
    extractNetwork(ip) {
        if (!ip || !ip.includes('/')) return null;
        
        const [addr, cidr] = ip.split('/');
        const octets = addr.split('.').map(Number);
        const mask = cidr ? parseInt(cidr) : 24;
        
        // Simple network calculation
        if (mask >= 24) {
            return `${octets[0]}.${octets[1]}.${octets[2]}.0/${mask}`;
        } else if (mask >= 16) {
            return `${octets[0]}.${octets[1]}.0.0/${mask}`;
        } else if (mask >= 8) {
            return `${octets[0]}.0.0.0/${mask}`;
        }
        
        return ip;
    }
}

// Create global instance
window.VyOSGenerator = new VyOSGenerator();

// Export for module systems if needed
if (typeof module !== 'undefined' && module.exports) {
    module.exports = VyOSGenerator;
}